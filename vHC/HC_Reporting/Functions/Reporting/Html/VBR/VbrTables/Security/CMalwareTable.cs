using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VeeamHealthCheck.Functions.Reporting.CsvHandlers;
using VeeamHealthCheck.Functions.Reporting.Html.Shared;
using VeeamHealthCheck.Shared;
using VeeamHealthCheck.Shared.Logging;

namespace VeeamHealthCheck.Functions.Reporting.Html.VBR.VbrTables.Security
{
    internal class CMalwareTable
    {
        private readonly CHtmlFormatting form = new();
        private readonly CLogger log = CGlobals.Logger;

        public CMalwareTable()
        {
        }

        public string MalwareSettingsTable()
        {
            string t = string.Empty;
            try
            {
                CCsvParser c = new();
                var m = c.MalwareSettings().ToList();
                if (m == null)
                {
                    // log message about missing files
                    this.log.Warning("Malware Settings CSV file is missing or empty. No data to display in Malware Settings table.");

                    return string.Empty;
                }

                CMalwareObject mo = m.FirstOrDefault();

                t = @"<br><h3>Malware Detection Settings</h3>";
                t += this.form.Table();
                t += "<thead>";
                t += this.form.TableHeaderLeftAligned("Malware Feature", "Lists a Veeam Backup & Replication Feature for Malware detection and if the feature is in use.");
                t += this.form.TableHeader("Details", "Details of the Malware Detection feature.");
                t += "</thead>";
                t += this.form.TableBodyStart();
                t += "<tr>";

                t += this.form.TableDataLeftAligned("Inline Entropy Analysis", "Details if Inline Entropy Analysis is enabled.");
                string inlineScantoolTip = "Inline Malware Scan is a feature that scans files for malware during backup and replication jobs. This feature is disabled by default. If you disable this feature, Veeam Backup & Replication will not scan files for malware during backup and replication jobs. Be aware that it may increase CPU usage (10-15% on average) on the backup proxy or Veeam agent, depending on the workload type and amount of data.";

                // t += mo.InlineMalwareScanEnabled ? _form.TableData(_form.True, inlineScantoolTip) : _form.TableData(_form.False, inlineScantoolTip);
                t += mo.InlineMalwareScanEnabled ? this.form.TableData(this.form.True, inlineScantoolTip) : this.form.TableData(this.form.False, inlineScantoolTip);
                t += "</tr><tr>";

                string sensitivityToolTip = "The Sensitivity setting defines the level of sensitivity for entropy scans. The Sensitivity setting is used to determine the entropy threshold that Veeam Backup & Replication uses to detect potentially malicious files. The Sensitivity setting can be set between Low, Normal or Extreme. The default Sensitivity setting is Normal.";

                t += this.form.TableDataLeftAligned("Entropy Scan Sensitivity", "Level of sensitivity for entropy scans");
                if (mo.InlineMalwareScanEnabled)
                {
                    t += this.form.TableData(mo.Sensitivity, sensitivityToolTip);
                }
                else
                {
                    t += this.form.TableData("N/A", sensitivityToolTip);
                }

                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Quick Backup on External Event", "Details if Quick Backup on External Event is enabled.");
                string quickBackupToolTip = "Quick Backup on External Event is a feature that allows you to create a backup of a VM when an external event is triggered via Veeam's Incident API. Quick Backup on External Event is disabled by default. ";
                t += mo.QuickBackupOnExternalEventEnabled ? this.form.TableData(this.form.True, quickBackupToolTip) : this.form.TableData(this.form.False, quickBackupToolTip);
                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Guest Index Scan", "Details if Guest Index Scan is enabled.");
                if (mo.GuestIndexScanEnabled == true)
                {
                    t += this.form.TableData(this.form.True, string.Empty);
                }
                else
                {
                    t += this.form.TableData(this.form.False, string.Empty);
                }

                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Guest Index Scan Enabled On Job(s)", "Details if Guest Index Scan is enabled on at least 1 job.");
                var jobCsv = c.JobCsvParser();
                t += jobCsv.Any(x => x.IndexingType != "None") ? this.form.TableData(this.form.True, string.Empty) : this.form.TableData(this.form.False, string.Empty);
                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Update Extensions List Periodically", "Details if Update Extensions List Periodically is enabled.");
                string updateToolTip = "Update Extensions List Periodically is a feature that updates the list of file extensions that Veeam Backup & Replication considers as potentially dangerous. This feature is enabled by default. If you disable this feature, Veeam Backup & Replication will not automatically update the list of file extensions that it considers as potentially dangerous.";
                if (mo.GuestIndexScanEnabled)
                {
                    t += mo.UpdateExtensionsListPeriodically ? this.form.TableData(this.form.True, updateToolTip) : this.form.TableData(this.form.False, updateToolTip);
                }
                else
                {
                    t += this.form.TableData("N/A", updateToolTip);
                }

                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Threat Detection Engine", "Details if Inline Entropy Analysis is enabled.");
                string detectionEngineToolTip = "Is ThreatHunter or BYO AV selected?";
                t += this.form.TableData(mo.DetectionEngine, detectionEngineToolTip);
                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Scan Archives", "Is the detection engine set to scan archive backups?");
                string ScanArchiveScantoolTip = string.Empty;
                t += (mo.ScanArchives ?? false) ? this.form.TableData(this.form.True, ScanArchiveScantoolTip) : this.form.TableData(this.form.False, ScanArchiveScantoolTip);
                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Notifications Recipient(s)", "Shows who recieves notifications about malware events");
                string notificationsToolTip = "Recipient(s) of malware notifications";
                t += this.form.TableData(mo.NotificationOptions, notificationsToolTip);
                t += "</tr><tr>";

                //
                string iocEnabledToolTip = "Use Indicators of Compromise is a feature that allows you to scan files for indicators of compromise. This feature is disabled by default. If you enable this feature, Veeam Backup & Replication will scan files for indicators of compromise during backup and replication jobs.";
                t += this.form.TableDataLeftAligned("Use Indicators of Compromise", "Details if Use Indicators of Compromise is enabled.");
                t += (mo.UseIndicatorsOfCompromiseEnabled ?? false) ? this.form.TableData(this.form.True, iocEnabledToolTip) : this.form.TableData(this.form.False, iocEnabledToolTip); t += "</tr><tr>";

                t += "</tr><tr>";

                t += this.form.TableDataLeftAligned("Recon Installed:", "Is the Recon Scanner installed?");
                t += CGlobals.IsReconDetected ? this.form.TableData(this.form.True, "The Recon Scanner is installed and configured.") : this.form.TableData(this.form.False, "The Recon Scanner is not installed or configured.");
                t += "</tr><tr>";
                t += this.form.TableDataLeftAligned("Recon Last Scan:", "The last time the Recon Scanner was run.");
                t += CGlobals.LastReconRun == DateTime.MinValue ? this.form.TableData("N/A", "The Recon Scanner has not been run yet.") : this.form.TableData(CGlobals.LastReconRun.ToString("yyyy-MM-dd HH:mm:ss"), "The last time the Recon Scanner was run.");

                t += "</tr>";
                t += this.form.EndTable();
            }
            catch (Exception e)
            {
                this.log.Error("Failed to parse Malware Settings table:");
                this.log.Error(e.Message);
                throw;
            }

            return t;
        }

        public string MalwareExclusionsTable()
        {
            string t = string.Empty;
            try
            {
                CCsvParser c = new();
                var m = c.MalwareExclusions().ToList();

                // CMalwareObject mo = m.FirstOrDefault();

                t = @"<br><h3>Malware Excluded Objects</h3>";
                t += this.form.Table();
                t += "<thead>";
                t += this.form.TableHeaderLeftAligned("Excluded Item", "Name of the excluded sytem.");
                t += this.form.TableHeader("Platform", "Platform of the excluded item.");
                t += "</thead>";
                t += this.form.TableBodyStart();

                // if the list is empty, add a row that says "No Exclusions Found"
                if (m.Count == 0)
                {
                    t += "<tr>";
                    t += this.form.TableDataLeftAligned("No Exclusions Found", string.Empty);
                    t += this.form.TableData(string.Empty, string.Empty);
                    t += "</tr>";
                }
                else
                {
                    foreach (var obj in m)
                    {
                        string name = obj.Name;
                        if (CGlobals.Scrub) { name = CGlobals.Scrubber.ScrubItem(name, Scrubber.ScrubItemType.Server); }
                        t += "<tr>";
                        t += this.form.TableDataLeftAligned(name, string.Empty);
                        t += this.form.TableData(obj.Platform, string.Empty);
                        t += "</tr>";
                    }
                }

                t += this.form.EndTable();
            }
            catch (Exception e)
            {
                this.log.Error("Failed to parse Malware Exclusions table:");
                this.log.Error(e.Message);
                throw;
            }

            return t;
        }

        public string MalwareEventsTable()
        {
            string t = string.Empty;
            try
            {
                CCsvParser c = new();
                var lst = c.MalwareEvents().ToList();

                // select items from the list where DetectionTime is within range of CGlobals.ReportDays
                // m = m.Where(x => new TimeSpan(DateTime.Parse(x.DetectionTime).Ticks).TotalDays >= CGlobals.ReportDays).ToList();
                List<CMalwareEvents> m = new();
                foreach (var item in lst)
                {
                    item.DetectionTime = item.DetectionTime.Replace("T", " ").Replace("Z", string.Empty);
                    var dt = DateTime.Parse(item.DetectionTime);
                    TimeSpan diff = DateTime.Now - dt;
                    if (diff.TotalDays <= CGlobals.ReportDays)
                    {
                        m.Add(item);
                    }
                    else
                    {
                        // do nothing   
                    }
                }

                // reduce the m variable to a smaller subset where m[x].DetectionTime is converted to a datetime and then checked to be equal to or less than the CGlobals.ReportDays Range
                // var testList = m = m.Where(x => DateTime.Parse(x.DetectionTime) <= DateTime.Now.AddDays(-CGlobals.ReportDays)).ToList();

                t = @"<br><h3>Malware: Events Summary</h3>";
                t += this.form.Table();
                t += "<thead>";
                t += this.form.TableHeaderLeftAligned("Event/Info", string.Empty);
                t += this.form.TableHeader("Count", "Details of the Malware Detection feature.");
                t += "</thead>";

                // t += _form.TableHeader("Info", "Details of the Malware Detection feature.");
                t += this.form.TableBodyStart();

                // List<string> messages = m.Select(x => x.Message).Distinct().ToList();
                t += "<tr>";
                t += this.form.TableDataLeftAligned("Total Events", string.Empty);
                t += this.form.TableData(m.Count.ToString(), string.Empty);

                // t += _form.TableData("", "");
                t += "</tr>";
                t += "<tr>";
                t += this.form.TableDataLeftAligned("Total Objects Flagged", string.Empty);
                t += this.form.TableData(m.Select(x => x.ObjectId).Distinct().Count().ToString(), string.Empty);

                // t += _form.TableData(String.Join(",</br>", m.Select(x => x.ObjectName).Distinct().ToList()), "");
                t += "</tr>";
                t += "<tr>";
                t += this.form.TableDataLeftAligned("Total Unique Event Types", string.Empty);
                t += this.form.TableData(m.Select(x => x.Message).Distinct().Count().ToString(), string.Empty);

                // t += _form.TableData(String.Join(",</br>", m.Select(x => x.Message).Distinct().ToList()), "");
                t += "</tr>";

                t += this.form.EndTable();
            }
            catch (Exception e)
            {
                this.log.Error("Failed to parse Malware Events table:");
                this.log.Error(e.Message);
                throw;
            }

            return t;
        }

        public string MalwareInfectedObjectsTable()
        {
            string t = string.Empty;
            try
            {
                CCsvParser c = new();
                var m = c.MalwareInfectedObjects().ToList();

                // CMalwareObject mo = m.FirstOrDefault();

                t = @"<br><h3>Malware: Infected Objects</h3>";
                t += this.form.Table();
                t += "<thead>";

                // create table headers like t += _form.TableHeader() for these: ObjectId	ObjectName	DetectedDateTime	Severity	Types	Platform	ObjectHostName
                // t += _form.TableHeader("ObjectId", "The ID of the infected object.");
                t += this.form.TableHeaderLeftAligned("ObjectName", "The name of the infected object.");
                t += this.form.TableHeader("DetectedDateTime", "The date and time the object was detected.");
                t += this.form.TableHeader("Severity", "The severity of the infection.");
                t += this.form.TableHeader("Types", "The type of infection.");
                t += this.form.TableHeader("Platform", "The platform of the infected object.");
                t += this.form.TableHeader("ObjectHostName", "The host name of the infected object.");
                t += "</thead>";
                t += this.form.TableBodyStart();

                // if the list is empty, add a row that says "No Infected Objects Found"
                if (m.Count == 0)
                {
                    t += "<tr>";
                    t += this.form.TableDataLeftAligned("No Infected Objects Found",
                        string.Empty);
                    t += this.form.TableData(string.Empty, string.Empty);
                    t += this.form.TableData(string.Empty, string.Empty);
                    t += this.form.TableData(string.Empty, string.Empty);
                    t += this.form.TableData(string.Empty, string.Empty);
                    t += this.form.TableData(string.Empty, string.Empty);
                    t += "</tr>";
                }

                // else, loop through the list and add each item to the table
                else
                {
                    foreach (var obj in m)
                    {
                        string name = obj.ObjectName;
                        string host = obj.ObjectHostName;
                        if (CGlobals.Scrub)
                        {
                            name = CGlobals.Scrubber.ScrubItem(name, Scrubber.ScrubItemType.Server);
                            host = CGlobals.Scrubber.ScrubItem(host, Scrubber.ScrubItemType.Server);
                        }

                        t += "<tr>";

                        // t += _form.TableData(obj.ObjectId, "");
                        t += this.form.TableDataLeftAligned(name, string.Empty);
                        t += this.form.TableData(obj.DetectedDateTime, string.Empty);
                        t += this.form.TableData(obj.Severity, string.Empty);
                        t += this.form.TableData(obj.Types, string.Empty);
                        t += this.form.TableData(obj.Platform, string.Empty);
                        t += this.form.TableData(host, string.Empty);
                        t += "</tr>";
                    }
                }

                t += this.form.EndTable();
            }
            catch (Exception e)
            {
                this.log.Error("Failed to parse Malware Infected Objects table:");
                this.log.Error(e.Message);

                throw;
            }

            return t;
        }
    }

    public class UniversalCollection<T>
    {
        private readonly List<T> items = new List<T>();

        public void Add(T item)
        {
            this.items.Add(item);
        }

        public IEnumerable<T> GetItems()
        {
            return this.items;
        }
    }
}
