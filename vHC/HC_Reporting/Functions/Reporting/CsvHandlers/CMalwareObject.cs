using CsvHelper.Configuration;
using CsvHelper.Configuration.Attributes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace VeeamHealthCheck.Functions.Reporting.CsvHandlers
{
    public class CMalwareObject
    {
        // Core properties (always present)
        public bool InlineMalwareScanEnabled { get; set; }
        public string Sensitivity { get; set; }
        public bool QuickBackupOnExternalEventEnabled { get; set; }
        public bool GuestIndexScanEnabled { get; set; }
        public bool UpdateExtensionsListPeriodically { get; set; }
        public string SuspiciousExtensions { get; set; }
        public string NonSuspiciousExtensions { get; set; }
        public string NotificationOptions { get; set; }

        // Optional properties (may not be present in older versions)
        public bool? UseIndicatorsOfCompromiseEnabled { get; set; }
        public string DetectionEngine { get; set; }
        public bool? ScanArchives { get; set; }
    }

    public sealed class CMalwareObjectMap : ClassMap<CMalwareObject>
    {
        public CMalwareObjectMap()
        {
            // Map core properties that are always present
            Map(m => m.InlineMalwareScanEnabled).Name("InlineMalwareScanEnabled");
            Map(m => m.Sensitivity).Name("Sensitivity");
            Map(m => m.QuickBackupOnExternalEventEnabled).Name("QuickBackupOnExternalEventEnabled");
            Map(m => m.GuestIndexScanEnabled).Name("GuestIndexScanEnabled");
            Map(m => m.UpdateExtensionsListPeriodically).Name("UpdateExtensionsListPeriodically");
            Map(m => m.SuspiciousExtensions).Name("SuspiciousExtensions");
            Map(m => m.NonSuspiciousExtensions).Name("NonSuspiciousExtensions");
            Map(m => m.NotificationOptions).Name("NotificationOptions");

            // Optional properties - these will be ignored if not present in the CSV
            Map(m => m.UseIndicatorsOfCompromiseEnabled).Name("UseIndicatorsOfCompromiseEnabled").Optional();
            Map(m => m.DetectionEngine).Name("DetectionEngine").Optional();
            Map(m => m.ScanArchives).Name("ScanArchives").Optional();
        }
    }
    public class CMalwareExcludedItem
    {
        [Index(0)]
        public string Id { get; set; }
        [Index(1)]
        public string Name { get; set; }
        [Index(2)]
        public string Platform { get; set; }
        [Index(3)]
        public string Note { get; set; }

    }
    public class CMalwareInfectedObjects
    {
        // create a list of malware objects from this: ObjectId	ObjectName	DetectedDateTime	Severity	Types	Platform	ObjectHostName

        [Index(0)]
        public string ObjectId { get; set; }
        [Index(1)]
        public string ObjectName { get; set; }
        [Index(2)]
        public string DetectedDateTime { get; set; }
        [Index(3)]
        public string Severity { get; set; }
        [Index(4)]
        public string Types { get; set; }
        [Index(5)]
        public string Platform { get; set; }
        [Index(6)]
        public string ObjectHostName { get; set; }


    }
    public class CMalwareEvents
    {
        //create a list of malware object from this: Id	ObjectName	ObjectId	DetectionTime	Type	State	CreatedBy	Status	Message	EncryptedDataInfo

        [Index(0)]
        public string Id { get; set; }
        [Index(1)]
        public string ObjectName { get; set; }
        [Index(2)]
        public string ObjectId { get; set; }
        [Index(3)]
        public string DetectionTime { get; set; }
        [Index(4)]
        public string Type { get; set; }
        [Index(5)]
        public string State { get; set; }
        [Index(6)]
        public string CreatedBy { get; set; }
        [Index(7)]
        public string Status { get; set; }
        [Index(8)]
        public string Message { get; set; }
        [Index(9)]
        public string EncryptedDataInfo { get; set; }

    }
}
